그림 참조) https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95

## 객체지향 프로그래밍 이란?

여러 독립적인 부품 (객체) 들이 서로 상호작용하여 하나의 프로그램으로서 동작하는것을 객체지향이라고 생각합니다.

### **객체지향 프로그래밍을 쓰는 이유는?**

부품 즉, 객체들이 독립적이기 때문에 코드의 변경이 용이하고 코드의 재사용성이 좋아 확장성이 좋아진다는 장점이 있습니다. 또한 코드에 문제가 생긴다면 컴퓨터가 문제가 생겼을 때 전체를 교체하지 않고 부품만 교체하는 것 처럼 독립적인 객체만 수정할 수 있기 때문에 코드의 유지보수가 용이하다는 장점을 갖습니다.

### **1. 추상화(Abstration)**

> **객체의 공통적인 속성과 기능을 추출하여 정의하는것**
> 

객체 지향적 설계에 있어서 인터페이스는 어떤 **객체의 역할만을 정의**하여 객체들 간의 관계를 보다 유연하게 연결하는 역할을 담당한다.

다른 말로 표현하면, 인터페이스에는 추상 메서드나 상수를 통해서 **어떤 객체가 수행해야 하는 핵심적인 역할만 선언**해두고, **실제적인 구현은 해당 인터페이스를 구현하는 각각의 객체들에서 하도록** 프로그램을 설계하는 것을 의미합니다.

이것을 객체 지향 프로그래밍에서는 **역할과 구현의 분리**라고 하며, 이 부분이 아래에서 살펴볼 다형성과 함께 유연하고 변경이 용이한 프로그램을 설계하는 데 가장 핵심적인 부분이라 할 수 있습니다. 정리하면, 객체 지향 프로그래밍에서는 **보다 유연하고 변경에 열려있는 프로그램을 설계하기 위해 역할과 구현을 분리**하는데, 여기서 역할에 해당하는 부분이 인터페이스를 통해 추상화될 수 있습니다.

### **2. 상속(Inheritance)**

> **기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소**
> 

❓클래스로 상속받는건 좋은데 인터페이스는 그냥 기능이나 필드만 정의해두는거 아닌가? 어짜피 각자의 클래스에서 다시 오버라이딩으로 정의할거면 왜 인터페이스를 사용하는 걸까?

❓인터페이스가 공통적인 부분을 계속 재정의 안하고 구현체에서 각각 구현하면 된다는데 결국 구현체가 아니라 그냥 클래스를 상속 받아서 기능을 구현하나 구현체로써 기능의 이름만 받고 오버라이딩으로 재정의하는거나 똑같지 않나? 왜 인터페이스를 사용해서 오버라이딩을 통해서 사용하는 이유가 뭘까?

❗**결합도 때문이다!!**

❓상속과 인터페이스와 추상화를 통한 구현의 차이는 뭐지??

❗사실 이 부분이 앞서 추상화에서 봤었던 인터페이스를 통한 구현과 상속을 구분하는 핵심적인 차이 중에 하나라 할 수 있습니다. 즉, 양자 모두 상위 클래스-하위 클래스의 관계를 전제하면서 공통적인 속성과 기능을 공유할 수 있지만, 상속의 경우 상위 클래스의 속성과 기능들을 하위 클래스에서 그대로 받아 사용하거나 오버라이딩을 통해 선택적으로 재정의하여 사용할 수 있는 반면, 인터페이스를 통한 구현은 반드시 인터페이스에 정의된 추상 메서드의 내용이 하위 클래스에서 정의되어야 합니다.

### **3. 다형성**

> **어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질**
> 

메서드 오버라이딩과 메서드 오버로딩도 다형성의 한 중요한 예시지만, 객체 지향의 맥락에서 이것보다 더 중요한 다형성의 정의는 다음입니다.

객체 지향 프로그래밍에서 다형성이란 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것을 의미한다. 좀 더 구체적으로, 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것이다. 

**`Main` 실행 클래스**

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/a847581b-329a-40bd-a47c-b6d0de665ca7)

위의 코드를 확인해보면, **`상위클래스 타입의 참조변수로 하위클래스 객체를 참조하는 것`** 의 의미를 조금 더 구체적으로 이해할 수 있습니다. 원래 우리가 사용했던 방식은 하위 클래스의 객체를 생성하여 하위 클래스 타입의 참조 변수에 할당해주었지만, 다형성을 활용한 객체 생성 방식에서는 하위 클래스의 객체를 생성하여 상위 클래스 타입의 참조변수 **`car2`** 에 할당해주고 있습니다.

**`Vehicle` 인터페이스 적용 전**

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/d4ab5d02-9566-4e95-8873-e1831981f542)

위의 코드 예제를 도식을 사용하여 표현하면 아래와 같이 그려볼 수 있을 것이고, 우리는 `Driver 클래스가 Car 클래스와 MotorBike 클래스에 의존하고 있다` 라고 설명할 수 있습니다. 즉 **`Driver`** 클래스와 다른 두 개의 클래스가 서로 직접적인 관계를 가지고 있는데, 이러한 상황을 **객체들 간의 결합도가 높다**고 표현합니다

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/0360ea40-2de3-4557-80a1-2f02b83c109f)

하지만 이렇게 **결합도가 높은 상태는 객체 지향적인 설계를 하는 데 매우 불리합니다.**

- 이동 수단이 자동차와 오토바이 단 2개가 아니라 수 십, 수 백개라면? 똑같은 코드를 수 십, 수 백 번 작성해야 한다.
- **`MotorBike`** 클래스가 다른 클래스 **`MotorCycle`** 클래스로 변경되어야 하는 경우 **`Driver`** 안에 매개변수로 전달되는 참조변수의 타입과 참조변수를 수정할 수밖에 없는 상황이 발생한다. 그리고 코드가 많아질수록 복잡해진다. 이것은 마치 운전자가 운전을 배웠는데, 이동 수단이 바뀔 때마다 새롭게 운전을 배워야 하는 상황과 같다고 할 수 있다.

이런 맥락에서, 객체 지향 프로그래밍은 지금까지 학습한 추상화, 상속, 그리고 다형성의 특성을 활용하여 프로그래밍을 설계할 때 **역할**과 **구현을 구분**하여 **객체들 간의 직접적인 결합을 피하고, 느슨한 관계 설정을 통해 보다 유연하고 변경이 용이한 프로그램 설계**를 가능하게 만들었다. 이 부분이 사실 객체 지향 프로그래밍의 하이라이트이자 핵심이라 할 수 있다.

**`Vehicle` 인터페이스 적용 후**

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/a00e9a3f-f87b-4d0c-9571-dc399ad80e18)

이해를 돕기위해, 앞서 본 코드를 다시 도식으로 나타내보면 다음과 같습니다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/5bde34d7-7bf7-420b-aa75-26aa2c108eb2)

한눈에 봐도 코드의 중복이 사라지고, 코드가 훨씬 간결해졌다는 사실을 알 수 있다. 핵심은 **`drive()`** 메서드로 전달되는 매개변수의 타입을 상위 클래스인 인터페이스 타입 **`Vehicle`** 로 변경한 것이다. 

앞서 봤었던 도식에서는 **`Driver`** 클래스가 **`Car`** 와 **`MotorBike`** 클래스 각각과 직접적으로 연결되어 강한 결합도를 보였지만, 이제는 **`Vehicle`** 인터페이스를 통해 간접적으로 연결되어 결합도가 낮아졌다. 따라서, 이제 **`Driver`** 클래스는 더 이상 **각각의 클래스 내부의 변경이나 다른 객체가 새롭게 교체되는 것을 신경 쓰지 않아도 인터페이스에만 의존하여 수정이 있을 때마다 코드 변경을 하지 않아도 된다**.

물론 아직 모든 문제가 해결된 것은 아니다.

**`Main` 실행 클래스**

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/ef8eca82-06d8-4295-8391-11b321788b01)

**`new Car()`** 와 **`new MotorBike()`** 처럼 객체에 직접적으로 의존하고 있어서, 해당 객체를 다른 객체로 변경할 시 코드의 변경이 불가피하다. 즉, 다시 객체 간 높은 결합도를 보이는 상황이 초래되었다.

이 문제를 해결하기 위해 등장한 것이 바로 **의존관계 주입(dependency injection)**이라 부르는 스프링 프레임워크의 핵심적인 개념이다.

### **4. 캡슐화(Encapsulation)**

> **서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것**
> 
- **데이터 보호(data protection)** – 외부로부터 클래스에 정의된 속성과 기능들을 보호
- **데이터 은닉(data hiding)** – 내부의 동작을 감추고 외부에는 필요한 부분만 노출

자바의 캡슐화를 구현하기 위한 방법으로 **`getter/setter`** 메서드가 있다. 

**`Car` 클래스**

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/ca810e7b-c4eb-45f7-9c65-768d31c618b5)

위의 예제를 보면, 모든 속성값들이 **`private`** 접근 제어자로 선언되어 있고, **`getter/setter`** 메서드의 접근제어자만이 **`public`** 으로 열려있다. 따라서 선택적으로 외부에 접근을 허용할 속성과 그렇지 않을 속성을 **`getter/setter`** 메서드를 통해 설정해줄 수 있다.

캡슐화가 어떻게 객체 지향의 핵심적인 이점과 연결될 수 있는지 코드 예제를 통해 알아보자.

**`Driver` 클래스**

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/8b8a184a-9280-4802-8175-40a20b662631)

만약에 **`Car`** 클래스의 3가지 메서드들에 어떤 변경이 생겼다고 가정해본다. 그러면 해당 메서드들을 사용하고 있는 **`Driver`** 클래스의 **`drive()`** 메서드의 수정이 불가피하다. 다른 말로, **`Driver`** 클래스가 **`Car`** 클래스 의 세부적인 내부 로직을 속속히 너무 잘 알고 있고, 이것은 앞서 우리가 계속 피하고자 했던 **객체 간의 결합도가 높은 상태**를 의미한다.

이럴 때 우리는 캡슐화를 활용하여 객체의 자율성, 즉 하나의 객체가 해당 객체의 속성과 기능에 대한 독점적인 책임을 담당하도록 만들고, 이를 통해 객체 간의 결합도를 낮게 유지할 수 있다.

**`Car` 클래스**

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/4c4b0b38-a97a-4079-b8d2-c3460a0a2897)

**`Driver` 클래스**

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/7e9dc5de-983b-436c-aaad-4e3925214388)

아까와 출력값은 동일하지만, 기존의 **`Driver`** 클래스가 하나하나 호출해줬던 메서드들을 모두 **`operate()`** 메서드로 묶어 **`Car`** 클래스로 옮겨두었고, **`Driver`** 클래스에서는 내부 동작을 전혀 신경쓰지 않아도 단순히 **`operate()`** 메서드를 호출하여 사용하고 있다.

또한, **`operate()`** 메서드 내부의 메서드들은 외부에서 호출되어 사용할 일이 없으므로 접근 제어자를 모두 **`private`**으로 변경해주었다. 정리하면, **`Car`** 클래스와 관련된 기능들은 온전히 **`Car`** 에서만 관리되도록 하였고, 불필요한 내부 동작의 노출을 최소화하였다. 이제 **`Driver`** 클래스의 입장에서는 더 이상 **`Car`** 클래스의 내부 로직을 알지 못하고, 알 필요도 없어졌다.

이렇게 캡슐화를 활용하면, 객체 내부의 동작의 외부로의 노출을 최소화하여 각 객체의 자율성을 높이고, 이를 통해 객체 간 결합도를 낮추어 앞서 설명한 객체 지향의 핵심적인 이점을 잘 살리는 방법으로 프로그램을 설계하는 일이 가능하다.되도록 하였고, 불필요한 내부 동작의 노출을 최소화하였다. 이제 **`Driver`** 클래스의 입장에서는 더 이상 **`Car`** 클래스의 내부 로직을 알지 못하고, 알 필요도 없어졌다.
