![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/12b40ffa-e49a-41e9-ad93-b14a2191458c)(참조 : https://happycloud-lee.tistory.com/261?category=8322466)

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/e6b8617d-7bb8-4970-be13-6483eec43dd7)

## 최근의 변화

<aside>
📌 →

### 조직 구조의 변화

조직구조는 기능별 대규모 사일로Silo조직에서 서비스와 매핑 되어 있는 다기능 소규모 스쿼드Squad 조직으로 변화하고 있습니다.

아직 현재 많은 기업은 마케팅, 구매, R&D, 영업, IT 등 기능별로 대규모 인원을 가진 BU(Business Unit)가 명확히 나뉘어져 있습니다. 그 때문에 BU간에 소통과 협업에 한계가 많습니다. 비슷한 제품/서비스를 중복해서 투자하는 경우도 흔하고요.

이제는 각 제품/서비스에 필요한 제품 책임자, 서비스 기획자, 개발자, 운영자, 디자이너 등이 8~10명 정도의 스쿼드팀을 이루어 기획, 개발, 운영을 하면서 제품/서비스를 계속 발전시켜 나가는 조직으로 변화하고 있습니다.

이러한 조직구조의 변화는 아직 본격적으로 시작되지 않았지만 빅테크와 금융권을 중심으로 활발하게 변화의 노력을 하고 있습니다.

예를 들어 KB국민은행은 사업조직(Biz)과 기술조직(Tech)이 함께 일하는 25개 플랫폼조직을 8개 사업그룹 안에 신설하여 운영중에 있습니다. 이 외에도 대표적인 국내 기업으로는 배달앱 1위인 ‘배달의 민족’, 이커머스 1위인 ‘신세계그룹’등이 있습니다. (애자일 조직 사례)

### 서버 단위의 변화

서버 단위가 점점 더 작아지고 있습니다.

2000년 전까지만 해도 서비스를 운영하기 위한 서버는 물리적인 머신 이였고, → 물리적인 머신 1대를 여러 대의 가상머신(VM: Virtual Machine)으로 나누어 CPU와 메모리 등의 자원을 효율적으로 사용할 수 있게 되었습니다.

도커Docker라는 컨테이너 기술이 나오면서 물리적인 머신 또는 가상머신을 컨테이너로 나누어 서비스하기 시작했습니다. 컨테이너의 목적은 자원의 효율적인 사용 보다는 서비스 상호간에 영향도를 없애는 것이었습니다. 서비스에 필요한 OS, WAS(Web Application Server), 라이브러리, 어플리케이션 소스를 하나의 컨테이너 단위로 합침으로써 각 서비스가 독립적으로 배포, 버전업, 인스턴스 수 증감이 가능하게 한 것입니다.

### 어플리케이션 단위의 변화

어플리케이션 단위도 점점 더 작아지고 있습니다.

우리가 보통 구매 시스템, 영업 시스템, 모바일뱅킹 시스템과 같이 ‘시스템’이라고 부르는 것은 여러가지 서비스가 하나로 뭉쳐진 모놀리식 Monolithic 서비스입니다.

모놀리식 서비스의 문제점은 내부의 서비스가 서로 영향을 미친다는 것입니다. 그래서 한 서비스를 새로운 버전으로 배포했는데 다른 서비스가 의도치 않은 영향을 받아 장애가 발생할 수가 있습니다. 그래서 사소한 기능 변경이라도 운영서버에 배포하려고 하면 전체 기능을 철저하게 테스트하고 관련자들이 긴장하면서 모두 대기해야 했습니다.

마이크로서비스는 이러한 서비스간의 영향도를 최소화하고자 하는 목적으로 나왔습니다.

큰 서비스를 작게 분할하고 마이크로서비스별로 자체적인 데이터베이스를 갖게 하며 서로 API로 통신하게 함으로써 영향도를 최소화하겠다는 것입니다.

이렇게 영향도를 최소화함으로써 각 마이크로서비스는 독립적으로 배포, 버전업, 인스턴스 증감이 될 수 있고 비즈니스의 요구에 보다 더 민첩하게 대응할 수 있게 되었습니다.

즉, 마이크로서비스의 목적은 서비스간 영향도 최소화라는 측면에서 컨테이너와 동일합니다.

그래서 마이크로서비스를 컨테이너화 해서 서비스하는 것이 자연스런 방향이 되었습니다.

### 서비스 플랫폼의 변화

클라우드로의 변화입니다.

클라우드가 없던 시절에는 모든 IT자원을 각 기업이 소유해야 했습니다. 하드웨어, 소프트웨어, 운영인력등을 자체적으로 갖고 있어야 했죠.

클라우드는 이러한 자원들을 임대하여 사용할 수 있는 방법을 제공했습니다.

클라우드의 목적은 단순히 자원의 임대를 통한 비용 절감이 아닙니다. 사실 초기 비용이 줄지 전체 비용이 그렇게 획기적으로 줄지도 않습니다.

그 진정한 목적은 혁신적인 서비스를 만들고 발전시켜나가는 혁신 플랫폼이라는 것입니다.

예를 들어 비즈니스조직에서 좋은 아이디어를 내었고 그걸 IT서비스로 경쟁사보다 먼저 만들어 시장에 출시해야 하는데 하드웨어와 소프트웨어 구매하고 네트워크 작업하는데 한달 이상 걸린다면 그 아이디어는 무용지물이 될 수 있습니다.

클라우드는 이러한 비즈니스의 요구에 민첩하게 대응하여 혁신적인 서비스를 신속하게 만들고 발전시킬 수 있는 강력한 혁신 플랫폼이라는데 가장 큰 가치가 있습니다.

### 일하는 방식의 변화를 주도하는 프레임워크

일하는 방식 변화 프레임워크를 구성하는 4가지 축을 애자일, 마이크로서비스, 데브옵스, 클라우드라고 정의 합니다.

기업이 생존하고 지속성장 하려면 ‘애자일’이라는 사상과 철학을 구성원 모두가 이해하고 실천하여야 합니다.

‘마이크로서비스’와 ‘데브옵스’는 기업의 생존과 지속성장을 실현하는 강력한 수단과 도구이며, 그 기반이 되는 혁신 플랫폼이 ‘클라우드’입니다.

그래서 ‘왜 마이크로서비스가 출현했는가’의 근본적인 답은 ‘기업과 조직의 생존과 지속성장’을 위한 일하는 방식 변화를 위해 가장 성공 확률이 높은 수단의 하나이기 때문이라고 할 수 있습니다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/d8ebfcd4-1eb9-460d-a5db-2bd266b53b2f)

일하는 방식 변화 프레임워크를 구성하는 애자일, 마이크로서비스, 데브옵스, 클라우드를 WHY, HOW, WHAT의 관점에서 정리하면 아래와 같습니다.

여기서 WHY는 비전과 신념이고 HOW는 그 방법이며 WHAT은 그 결과입니다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/c6a57ea5-710a-407c-b2a0-216482722724)

</aside>

## ****모놀리식 아키텍처 (****Monolith)

<aside>
📌 →

모놀리식 아키텍처는 소프트웨어 프로그램의 전통적인 모델로, 자체 포함 방식이며 다른 애플리케이션과 독립적인 통합된 유닛으로 만들어집니다. “모놀리스"라는 단어는 거대하고 빙하 같은 것을 의미하는 경우가 많은데, 소프트웨어 설계의 모놀리식 아키텍처도 크게 다르지 않습니다. 모놀리식 아키텍처는 모든 비즈니스 관련 사항을 함께 결합하는 하나의 코드 베이스를 갖춘 대규모의 단일 컴퓨팅 네트워크입니다. 이러한 종류의 애플리케이션을 변경하려면 코드 베이스에 액세스하고 서비스 측 인터페이스의 업데이트된 버전을 구축 및 배포하여 전체 스택을 업데이트해야 합니다. 이로 인해 업데이트에 제한이 많고 시간이 오래 걸립니다.

프로젝트 초기에는 코드 관리, 인지 오버헤드 및 배포의 용이성 면에서 모놀리스가 편리할 수 있습니다. 모놀리스에서 모든 것을 한꺼번에 릴리스할 수 있기 때문입니다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/4c078f0b-93ad-4329-b6d6-d6a5f92117d0)

## **모놀리식 아키텍처의 장점**

---

다양한 요인에 따라, 조직에 모놀리식 아키텍처 또는 마이크로서비스 아키텍처가 도움이 될 수 있습니다. 모놀리식 아키텍처를 사용하여 개발하는 가장 큰 장점은 애플리케이션이 하나의 코드 베이스에 기반을 두어서 단순하기 때문에 개발 속도가 빠르다는 것입니다.

모놀리식 아키텍처의 장점에는 다음이 포함됩니다.

**손쉬운 배포** – 실행 파일 또는 디렉토리가 하나여서 배포가 더 쉽습니다.

**개발** – 하나의 코드 베이스로 애플리케이션을 구축하여 개발이 더 쉽습니다.

**성능** – 중앙 집중식 코드 베이스 및 리포지토리에서는 대부분 하나의 API만으로 마이크로서비스에서 여러 API가 수행하는 것과 동일한 기능을 수행할 수 있습니다.

**테스트 간소화** – 모놀리식 애플리케이션은 하나의 중앙 집중식 장치이므로 분산된 애플리케이션보다 엔드투엔드 테스트를 더 빠르게 수행할 수 있습니다.

**간편한 디버깅** – 모든 코드가 한 곳에 있으므로 요청을 따라가서 문제를 찾기가 더 쉽습니다.

## **모놀리식 아키텍처의 단점**

---

Netflix의 경우에서 볼 수 있듯이, 모놀리식 애플리케이션은 규모가 너무 커지고 확장이 어려워지면 더 이상 효과적이지 않습니다. 하나의 기능을 조금만 변경하려고 해도 전체 플랫폼을 컴파일하고 테스트해야 하기 때문에, 오늘날의 개발자들이 선호하는 애자일 접근 방식과 맞지 않습니다.

모놀리식 아키텍처의 단점에는 다음이 포함됩니다.

**느린 개발 속도** – 대규모 모놀리식 애플리케이션에서는 개발이 더욱 복잡해지고 속도가 느려집니다.

**확장성** – 개별 컴포넌트를 확장할 수 없습니다.

**안정성** – 모듈에 오류가 있으면 애플리케이션 전체의 가용성에 영향을 줄 수 있습니다.

**기술 채택의 장벽** – 프레임워크 또는 언어를 변경하면 애플리케이션 전체에 영향을 미치므로 변경 시 비용과 시간이 많이 소요되는 경우가 많습니다.

**유연성 부족** – 모놀리스의 경우 모놀리스에서 이미 사용한 기술로 제한됩니다.

**배포** – 모놀리식 애플리케이션을 약간만 변경하는 경우에도 전체 모놀리스를 다시 배포해야 합니다.

</aside>

## ****마이크로서비스 (****MSA)

<aside>
📌 →

간단하게 마이크로서비스라고도 하는 마이크로서비스 아키텍처는 독립적으로 배포 가능한 일련의 서비스를 이용하는 아키텍처 방법입니다. 큰 서비스를 작게 분할하고 마이크로서비스별로 자체적인 데이터베이스를 갖게 하며 서로 API로 통신하게 함으로써 영향도를 최소화하겠다는 것입니다.

마이크로서비스 채택은 팀이 사용자 요구 사항에 빠르게 적응할 수 있도록 하는 지속적 배포 관행의 기반이기 때문에 DevOps 채택과 함께 이루어지는 경우가 많습니다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/287fde73-9710-42d8-90e0-f1d76c5e4a63)

## **`마이크로서비스의 장점`**

---

마이크로서비스 아키텍처는 독립적으로 실행하는 유닛으로 구성되므로, 다른 서비스에 영향을 주는 일 없이 각 서비스를 개발, 업데이트, 배포 및 확장할 수 있습니다. 향상된 안정성, 가동 시간 및 성능으로 소프트웨어 업데이트를 더 자주 수행할 수 있습니다. 이전에는 업데이트를 일주일에 한 번 수행했다면 나중에는 하루에 두세 번까지 진행할 수 있게 되었습니다.

Vertigo의 장점에는 배포 속도 향상, 재해 복구, 비용 절감 및 성능 개선이 포함됩니다. 이를 통해 목표에 더 빨리 도달하는 동시에 고객에게 더 많은 가치를 제공할 수 있습니다.

또한 일반적으로 마이크로서비스를 사용하면 CI/CD(지속적 통합 및 지속적 배포)를 통해 팀이 코드를 더 쉽게 업데이트하고 릴리스 주기를 가속화할 수 있습니다. 팀에서 코드를 실험해 보고 문제가 발생하면 롤백할 수 있습니다.

간단히 설명하면 마이크로서비스의 장점은 다음과 같습니다.

**애질리티** – 배포가 잦은 소규모 팀에서 애자일 작업 방식을 유도합니다.

**유연한 확장** – 마이크로서비스가 부하 용량에 도달하면 해당 서비스의 새 인스턴스를 포함하는 클러스터에 신속하게 배포하여 부담을 완화할 수 있습니다. 이제 여러 인스턴스에 고객이 분산되어 있는 다중 테넌트 및 상태 비저장(stateless)이 되었으며 훨씬 더 큰 크기의 인스턴스를 지원할 수 있습니다.

**지속적 배포** – 이제 더 자주 릴리스하고 릴리스 주기가 빨라졌습니다. 이전에는 업데이트를 일주일에 한 번 수행했다면 나중에는 하루에 두세 번 정도까지도 수행할 수 있게 되었습니다.

**높은 유지 관리성 및 테스트 편의성** – 팀에서 새로운 기능을 실험해 보고 문제가 발생하면 롤백할 수 있습니다. 따라서 코드를 보다 쉽게 업데이트하고 새로운 기능의 시장 출시 시간을 단축할 수 있습니다. 또한 개별 서비스의 결함과 버그를 쉽게 격리하고 해결할 수 있습니다.

**독립적 배포 가능** – 마이크로서비스는 개별적인 유닛이므로 개별 기능을 빠르고 쉽게 독립적으로 배포할 수 있습니다.

**기술 유연성** – 마이크로서비스 아키텍처를 사용하면 팀에서 원하는 도구를 자유롭게 선택할 수 있습니다.

**높은 안정성** – 전체 애플리케이션이 중단될 위험 없이 특정 서비스에 대한 변경 사항을 배포할 수 있습니다.

**팀의 만족도 향상** – 마이크로서비스를 사용하는 Atlassian 팀은 더 자율적이며 풀리퀘스트가 승인될 때까지 몇 주씩 기다리지 않고도 직접 구축 및 배포할 수 있기 때문에 훨씬 더 만족도가 높습니다.

## **`마이크로서비스의 단점`**

---

소수의 모놀리식 코드 베이스에서 제품을 작동하는 더 많은 분산 시스템 및 서비스로 전환했을 때 의도하지 않은 복잡성이 발생했습니다. 처음에는 과거와 동일한 속도와 확신을 가지고 새로운 기능을 추가하는 데 어려움을 겪었습니다. 마이크로서비스는 복잡성을 증가시켜 무분별한 개발 확장 또는 관리되지 않는 급속한 성장으로 이어질 수 있습니다. 서로 다른 컴포넌트가 서로 어떻게 관련되어 있는지, 특정 소프트웨어 컴포넌트를 누가 소유하고 있는지, 또는 종속 컴포넌트를 방해하지 않으려면 어떻게 할지 판단하기가 어려울 수 있습니다.

Atlassian은 Vertigo를 통해 기존에 가지고 있던 제품과 앞으로 인수할 제품 및 만들 제품 모두를 지원할 공통의 기능을 구축했습니다. 제품이 하나인 회사의 경우 마이크로서비스가 필요하지 않을 수 있습니다.

마이크로서비스의 단점에는 다음이 포함됩니다.

**무분별한 개발 확산** – 마이크로서비스의 경우 여러 팀이 더 많은 장소에 더 많은 서비스를 만들기 때문에 모놀리스 아키텍처에 비해 더 복잡해집니다. 무분별한 개발 확산이 적절하게 관리되지 않으면 개발 속도가 느려지고 운영 성능이 저하되는 결과가 나타납니다.

**기하급수적인 인프라 비용** – 각각의 새 마이크로서비스는 테스트 도구, 배포 플레이북, 호스팅 인프라, 모니터링 도구 등에 대한 자체적인 비용이 발생할 수 있습니다.

**조직 오버헤드 추가** – 팀에서는 업데이트 및 인터페이스를 조정하기 위해 또 다른 커뮤니케이션과 공동 작업이 이루어져야 합니다.

**디버깅 문제** – 각 마이크로서비스는 자체적인 로그 집합을 가지고 있어 디버깅이 더 복잡합니다. 또한 여러 시스템에서 하나의 비즈니스 프로세스가 실행될 수 있으므로 디버깅이 더욱 복잡해집니다.

**표준화 부족** – 공통 플랫폼이 없어 여러 언어, 로깅 표준 및 모니터링이 사용될 수 있습니다.

**명확한 소유권 부족** – 더 많은 서비스가 도입됨에 따라 서비스를 실행하는 팀의 수도 늘어납니다. 시간이 지나면서 팀에서 어떤 서비스를 활용할 수 있는지, 그리고 지원을 받으려면 누구에게 문의해야 하는지 파악하기가 어려워집니다.

</aside>

## MSA와 Monolith

<aside>
📌 →

- "Monolith > apps > services > microservices"
- 첫째, 이건 규칙은 아니고 내 생각이 그렇다는 것. 대규모 분산 시스템을 구축해 본 사람은 실제로 그대로 작동하지 않으며, 적응해야 한다는 것을 알고 있음
- 둘째, 단계가 중요함
    - 5-50인 회사라면 그냥 Monolith로 가세요
    - 1만명 회사라면, 위의 모든 것들을 다 가지고 있을 것. 근데 예전과 달라진 생각들을 얘기해보자면..

## Why ? : 기본적으로 "Speed & Risk" 때문

- #1 전체 개발팀이 하나의 빅앱(전체 사이트가 Rails앱 이라고 생각해 볼 것)에서 개발하는게 더 쉬움
- #2 성장하면 필수로 가지게 될 분산시스템은, 자체적으로 위험한 수백개의 마이크로서비스 없이도 이미 추론하기가 어려움
- #3 완전히 마이크로로 간다면, 무분별한 확장을 처리하기 위해 새로운 개념을 도입해야 함
- #4 맞춤형(Bespoke) 인프라 서비스 또는 마이크로서비스는 부채의 극단적 개념임. 코드도 부채이지만 서비스가 그것의 극단적인 버전. 이게 뭘 의미하는지 생각해 볼 것. 레버리지 포인트가 되게 할 것
- 분산 시스템 엔지니어들은 중복되는걸 싫어하기 때문에 뭔가가 여러데서 이뤄진다면 "이걸 빼내서 마이크로 서비스를 만들자" 라고 생각함
- 이론적으로는 이게 맞고, 일이십개 까지 되는 것은 괜찮음. 하지만 수십개가 넘어가거나 대규모 회사를 넘어서 사용된다면 기술 문제가 아니라 조직의 문제가 됨
- 내가 이야기 하는 것이 잘못된 이분법 처럼 느껴지긴 하지만, 실제로 마이크로서비스에 대해서는 기술적인 도전들이 있고, 더 많은 조직적인 문제도 있음

## 내가 우려하는 것은

- #1 (특이하게 IT출신 CEO가 이끌지 않는 한) 인프라는 항상 우선순위에서 밀려남(get the short end of priority stick)
- #2 서비스가 너무 많으면 일반적으로 소유권 문제 및 경계 문제가 생김
- #3 수많은 마이크로서비스를 처리하기 위해 더 많은 도구를 도입함
- #4 가장 중요한 것은 라이브러리나 SDK가 되었어야할 각 마이크로서비스들이 프로덕션에 위험을 초래함

## 일반적으로 내가 추천하는 것은

- #1 가능하면 최대한 오래 Monolith를 유지
- #2 서비스는 인프라에 필요한 것에서 시작하고, 앱 개발쪽에서 시작하지 말 것
- #3 Mono를 쪼개야 한다면, 작은 서비스들이 아닌 큰 앱들로 분해할 것
- #4 각 새로운 앱은 회사내의 가상 벽이라고 생각할 것
- #5 가능하다면 마이크로서비스 대신 라이브러리를 선호
</aside>

## 애자일 방법론

<aside>
📌 →

'애자일(Agile)'이란 처음부터 끝까지 계획을 수립하고 개발하는 폭포수(Waterfall) 방법론과는 달리 개발과 함께 즉시 피드백을 받아서 유동적으로 개발하는 방법이다.

제품을 배포하고 고객의 피드백에 따라 빠르게 보완해 나가는 것을 필요로 하는 곳일수록 애자일 접근 방식에 따라 개발 단계를 진행해나간다.

하나의 기능을 조금만 변경하려고 해도 전체 플랫폼을 컴파일하고 테스트해야 하는 기존의 방식에서 변화하는 요구사항을 수용하기 쉬운 애자일 접근 방식에 따라 조직이 변화하고 있다.

</aside>

## 로드 밸런싱

> 쏟아지는 트래픽을 여러 대의 서버로 분산해주는 기술
> 

<aside>
📢 →

## `Scale-up, Scale-out`

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/02f81cce-2dd6-4e8a-b105-d333acad2cfa)

## **`로드 밸런싱 기법`**

로드 밸런싱 기법은 여러 가지가 있다. 서버의 능력을 고려하여 분배해야 하기 때문에 서버의 상황에 맞춰 적절한 방법을 선택해야 한다.

- 라운드로빈 방식(Round Robin Method)
    
    서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식이다. 클라이언트의 요청을 순서대로 분배하기 때문에 여러 대의 서버가 동일한 스펙을 갖고 있고, 서버와의 연결(세션)이 오래 지속되지 않는 경우에 활용하기 적합하다.
    
- 가중 라운드로빈 방식(Weighted Round Robin Method)
    
    각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분한다. 주로 서버의 트래픽 처리 능력이 상이한 경우 사용되는 부하 분산 방식이다. 예를 들어 A라는 서버가 5라는 가중치를 갖고 B라는 서버가 2라는 가중치를 갖는다면, 로드 밸런서는 라운드로빈 방식으로 A 서버에 5개 B 서버에 2개의 요청을 전달한다.
    
- IP 해시 방식(IP Hash Method)
    
    클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식이다. 사용자의 IP를 해싱해(Hashing, 임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 매핑하는 것, 또는 그러한 함수) 로드를 분배하기 때문에 사용자가 항상 동일한 서버로 연결되는 것을 보장한다.
    
- 최소 연결 방식(Least Connection Method)
    
    요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 트래픽을 배분한다. 자주 세션이 길어지거나, 서버에 분배된 트래픽들이 일정하지 않은 경우에 적합한 방식이다.
    
- 최소 응답 시간 방식(Least Response Time Method)
    
    서버의 현재 연결 상태와 응답 시간(Response Time, 서버에 요청을 보내고 최초 응답을 받을 때까지 소요되는 시간)을 모두 고려하여 트래픽을 배분한다. 가장 적은 연결 상태와 가장 짧은 응답 시간을 보이는 서버에 우선적으로 로드를 배분하는 방식이다.
    

## ****`L4 로드 밸런싱과 L7 로드 밸런싱`****

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/0448e7cf-e53c-4a24-a296-1270fd827073)

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/52c61104-8bef-45ec-89a6-4eb62fea16e1)

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/5b9346de-8d70-4a8a-907c-540e8991ba95)

→ L4, L7은 각각 Layer 4(전송 계층) 프로토콜과 Layer 7(응용 계층) 프로토콜의 헤더를 부하 분산에 이용하기 때문에 붙은 접두사이다. 모든 요청을 L4 혹은 L7 로드 밸런서가 받아 서버들에게 적절히 나누어 준다

L4 로드 밸런서는 네트워크 계층(IP, IPX)이나 전송 계층(TCP, UDP)의 정보(IP주소, 포트번호, MAC주소, 전송 프로토콜)를 바탕으로 로드를 분산한다.

L7 로드 밸런서는 애플리케이션 계층(HTTP, FTP, SMTP)에서 로드를 분산하기 때문에 HTTP 헤더, 쿠키 등과 같은 사용자의 요청을 기준으로 특정 서버에 트래픽을 분산하는 것이 가능하다. 쉽게 말해 패킷의 내용을 확인하고 그 내용에 따라 로드를 특정 서버에 분배하는 것이 가능한 것이다. URL에 따라 부하를 분산시키거나, HTTP 헤더의 쿠키 값에 따라 부하를 분산하는 등 클라이언트의 요청을 보다 세분화해 서버에 전달할 수 있다.

또한 L7 로드 밸런서의 경우 특정한 패턴을 지닌 바이러스를 감지해 네트워크를 보호할 수 있으며, DoS/DDoS와 같은 비정상적인 트래픽을 필터링할 수 있어 네트워크 보안 분야에서도 활용되고 있다.

</aside>
