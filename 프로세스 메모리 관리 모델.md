## 목차

- [1. 메모리 영역](#메모리-영역) <br/>
- [2. 메모리 주소 (Memory Address)](#메모리-주소-(Memory-Address)) <br/>
- [3. Buffer Overflow](#Buffer-Overflow) <br/>
- [4. PC와 SP](#PC와-SP) <br/>
- [5. 빅 엔디안 vs 리틀 엔디안](#빅-엔디안-vs-리틀-엔디안) <br/>

## 메모리 영역

- `javascript` 의 경우 `java` 와 다르게 변수를 선언할 수 있다는 점이 궁금했다. `javascript` 는`var` 라는 키워드에 number, boolean, string 등의 형태의 데이터를 마음대로 변환하여 대입할 수 있는 이유는 아래와 같은 방식으로 데이터를 할당하기 때문이다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/38352dc5-3b20-44d0-aafc-256c7d405f68)

각각의 데이터 즉, 숫자자료형 문자자료형 등등은 그 데이터의 단위가 다르고 **미리 확보하는 데이터 공간의 크기가 제각각인데** ( 숫자 - 8 byte, 영어- 1byte 등..)

만약 변수영역에 바로 값을 대입한다고 가정하고 미리 잡아놓은 공간보다 큰 데이터가 새로 할당이 된다면 부족한 공간 만큼 늘리는 작업이 필요할 것 이다. 

이러한 이유로 변수영역에서 값을 바로 할당하지 않고 저장하려는 데이터에 따라서, 데이터 영역의 공간을 새로 만들고, 그곳의 주소를 변수 영역에 할당하는 것이 이유이다.

### 효율적인 메모리관리

> 변수영역과 데이터영역을 나눠서 관리되는 것은 반복적인 데이터를 저장할때도 도움이 된다.
> 
- 예를 들어 숫자 5를 500개의 변수에 할당하는 작업을 할 때 변수영역에 값을 바로 할당한다면, 숫자형은 8byte를 사용하니, 8 * *500 =* 4000byte가 필요하지만 변수영역과 데이터영역을 나눈다면, 주소공간의 크기를 2byte라고 했을 때, 2 * 500 + 8 = 1008 byte 공간이 필요하다. 즉, 메모리를 효율적으로 관리할 수 있다.

## 메모리 주소 (Memory Address)

메모리 한칸은 1byte의 크기를 갖고 32bit 운영체제에서는 32개의 비트, 즉 **4바이트 길이의 주소**를 갖는다. 메모리의 최대 크기는 4,294,967,296 byte = 4GB 로 옛날 32bit 운영체제가 대다수인 시절 메모리를 4GB까지밖에 설치 할 수 없는 이유가 운영체제에 의해서 이다.

64bit 운영체제의 경우 64bit 는 8바이트이므로 하나의 주소가 **8바이트 길이의 주소**를 갖는다. 그리고 18,446,744,073,709,551,616 개의 주소를 가리킬 수 있고 18,446,744,073,709,551,616 byte = 16EB(엑사바이트) = 16384PB(페타바이트) = 16777216TB(테라바이트) 까지 이다.

(정확히는 16EiB = 16384PiB = 16777216TiB 이죠.) 한 마디로 이론적으로는 램을 16EB까지 설치 할 수 있다. (엑사바이트는 페타바이트의 1024배.)

512KB 의 경우 512KB = 512 * 1024 = 524288 이고, 524288 을 16진수로 변환하면 0x80000 이기 때문에 0x00000 부터 0x7FFFF 가 총 0x80000으로 표현했다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/044532a8-f9c5-4872-bd74-709c952d4a2f)

각 칸마다 16진수를 적용하여 순차적으로 0부터 1F 라고 하고 이보다 더 많이 늘려갈 수 있게 된다. 

int n = 50; 와 같이 n 변수를 선언했다고 가정하면 

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/fe1b53e8-b361-4038-9e07-3b6f369e5b4b)

메모리 어딘가에 저장한 변수 n이 있을 것이다. 그리고 int 형이기 때문에 4byte 크기를 가진다. 그 안에는 50이 있다. 하지만, 여기서 좀 더 엄밀히 말하면 n 변수는 메모리 안의 특정한 주소에 있다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/6f70e8dd-8f12-4a51-9d27-8bac41159ac9)

컴퓨터에 수십억 byte가 있다고 가정하면 변수 n 과 그 안에 있는 값 50은 0x12345678 이라는 위치에 있다고 가정할 수 있다. 메모리가 0x12345678 주소 이상의 byte를 가지고 있다고 하면 이 메모리 어딘가에 존재한다는 의미이다.

### 메모리 주소는 왜 16진수로 표현할까?

결론부터 말하면, 2진수나 10진수보다 16진수가 주소값을 짧게 표현할 수 있기 때문이다.

32개의 비트가 있다는 것은 0000 0000 0000 0000 0000 0000 0000 0000 부터 1111 1111 1111 1111 1111 1111 1111 1111 까지, 그러니까 2^32의 경우의 수를 갖는다.

하지만 이 주소를 2진수로 표현하기에는 너무 길어 편의상 16진수로 표현한다.

32bit에서는 0x00000000 ~ 0xFFFFFFFF

64bit에서는 0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF

### 메모리가 저장되는 위치

64비트 운영체제는 메모리 한 칸의 주소를 64비트로 표현하며 이는 8바이트와 같은 의미이고, 메모리 주소를 8바이트로 표현하기 때문에 포인터(주소를 가리키는 변수)의 크기 또한 8바이트이다

메모리 구조는 통상 Text, Data, Heap, Stack 으로 구분된다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/65cfa96d-7064-41b0-937c-b360558ee59d)

위 이미지처럼 상수, 함수는 Text 영역에, 전역, 정적변수는 Data 영역에, 지역변수들은 Stack 영역에, 동적할당이 되는 변수들은 Heap영역에 위치하게 된다. (malloc 함수는 런타임(실행중)에 메모리를 동적으로 할당할 수 있는 함수.)

위 4개의 영역 중 Text영역이 가장 낮은 주소(0에 가까운 주소), Data영역이 그 다음 주소, Heap영역이 Data영역의 다음 주소, Stack영역은 4개 영역 중 가장 높은 주소에 위치한다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/8b1ca7dc-09b8-4ee9-ac74-3e6c0cbaa42f)

먼저 **상수**는 Text영역이고 보면 다른 변수들과 비교했을 때 **가장 낮은주소에 위치**하는 것을 보실 수 있다.

**전역변수**는 초기화된 변수와 초기화되지 않은 변수 두 가지의 경우가 있다. 위 주소를 보면 상수보다는 높은 주소에, Heap영역인 동적할당변수보다는 낮은주소에 위치한다. (참고로 먼저 초기화 된 변수들이 더 낮은주소에 위치하고 모두 메모리에 올려지면 그 다음으로 초기화가 안된 변수들이 할당된다.) 

**정적변수** 또한 전역변수와 마찬가지로 Data영역으로 상수 영역에 있는 데이터보단 높은 주소에, Heap영역에 있는 데이터 주소보단 낮은 주소에 위치한다.

**함수**는 상수와 마찬가지로 Text영역이고, Data 영역보다 낮은 주소에 위치한다. 상수와 거의 유사한 주소에 위치하는 것을 볼 수 있고 함수안에 있는 변수들은 먼저 Text영역에 있는 함수를 호출함과 동시에 내부에 있는 변수들은 Stack영역에 할당하게 된다. 그리고 해당 함수가 종료되면 Stack메모리에 있던 함수의 변수들은 모두 pop 된다.

**지역변수**의 경우 Stack영역이다. Stack영역은 다른 영역과는 다르게 높은주소에서 낮은 주소로 메모리에 할당된다. 즉, 어느정도 높은 주소부터 시작하여 지역변수들이 선언될 때마다 낮은주소로 쌓인다. 이를 확인하기 위해 2개의 지역변수를 선언했고, 지역변수1은 0x7ffeefbff47c 이고, 그 다음으로 선언된 지역변수2는 int형 변수이므로 4byte의 크기이니 4칸만큼 작은 주소인 0x7ffeefbff478에 위치하는 것을 볼 수 있다.

마지막으로 **동적할당 변수**의 경우 Heap영역이다. Text, Data보다는 비교적 높은 주소에서 시작하지만, Stack영역에 비해서는 한없이 작은 주소에서 시작하는 것을 볼 수 있다.

## Buffer Overflow

→  Java에서는 JVM이 더 이상 참조되지 않는 데이터의 경우 Garbage Collector로 보내주지만, C 의 경우 GC가 없기 때문에 할당을 해제해준다. 이 문장 덕분에 free와 malloc의 관계에서 할당을 해제해 주지 않아도 gabage Collector로 처리한다면 해결할 수 있다.

Stack과 Heap은 프로그램이 실행하면서 생성되는 데이터들이 저장되는 공간이다. 해당 영역의 버퍼를 인위적으로 넘치게 만들어 인접한 데이터 영역까지 침범하게 만들고 결국 포인터 영역까지 침범하게 되는데 이 때 특정 명령을 넣어 프로그램을 붕괴시키거나 시스템의 권한을 상승시킬 수 있다.

**영역 간의 침범만이 Overflow 인 것은 아니다.**

예로들어 메모리에 할당 된 변수의 크기보다 더 큰 데이터를 입력시키는 경우도 Overflow 라고 한다. C언어에서는 대표적으로 데이터의 크기를 검사하지 않는 함수들인 strcpy(), gets(), scanf() 등이 있다.

즉, Overflow라는 큰 범주 안에 Heap Overflow, Stack Overflow 들이 있고 그 안에서도 데이터 버퍼의 Overflow와 메모리 영역에 대한 Overflow가 있다.

### **Stack Overflow**

Stack Overflow는 호출 스택이 할당 된 스택 영역 경계선 밖으로 넘어갈 때 발생한다. 가장 흔히 발생하는 경우는 '재귀호출'에서 발생한다.

재귀를 탈출 없이 무한 호출하도록 코드를 짜는 경우 이렇게 어떤 할당된 공간을 넘어서게 되면 overflow 가 발생한다고하고, 그 에러가 Stack에서 발생한 경우 Stack Overflow라고 하는 것이다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/c9192722-912b-4ac2-9fb4-cd96708a3f6a)

이렇게 Stack Overflow 가 발생하는 것을 방지하기 위해서는 재귀를 되도록 피하는 것이 좋다.

### **Heap Overflow**

Heap Overflow는 힙 영역에서 할당 된 영역의 경계선 밖으로 넘어갈 때 발생한다. 가장 흔히 발생하는 경우는 매우 큰 데이터를 생성하려고 할 때 발생한다.

스택과 마찬가지로 Heap영역보다 큰 데이터가 들어올 경우 발생하는데, Stack에서는 지역변수들이 스택에 쌓인다면, 반대로 Heap 영역에서는 동적으로 관리되는 데이터들이 일정 공간 이상 차지하게 될 경우 발생하는 것이다.

각 언어마다 Heap 에서 관리하는 데이터는 조금씩 다르지만, 대표적으로 malloc()같은 동적 할당 함수, 객체, 참조변수들이 Heap 영역에서 관리된다.

대표적으로 C 언어에서는 new 연산자가 없다. 그래서 int[] 같은 배열의 경우 전역, 정적변수가 아닌이상 Stack 영역에 쌓이거나 동적할당을 하고싶은 경우 malloc() 같은 함수를 쓴다. 반대로 C++나 Java같은 경우는 new연산자를 지원하고 있어 하나의 객체로 Heap영역에서 관리될 수 있게 하고 있다.

```arduino
int arr[10];		// C, C++ : Stack 영역
int *arr = new int[10]	// C++ : Heap 영역
int[] arr = new int[10]	// Java : Heap 영역
```

이렇게 Heap 영역을 넘어가서 에러가 발생하는 경우가 생각보다 많이 있다. 그나마 Java에서는 JVM(자바 가상머신)이 더이상 참조되지 않는 데이터들의 경우 알아서 메모리를 반납해주는 GC(Garbage Collector : 가비지 컬렉터)가 있기 때문에 Heap 메모리 관리에 보다 수월하지만, C, C++같은 경우는 GC가 따로 없기 때문에 반드시 더이상 쓰지 않는 동적 할당 변수들을 해제해주어야 한다.

만약 해제 하지 않는 경우 메모리 누수(Memory Leak)가 발생한다.

또한 동적으로 관리해야 하는 변수들의 경우 어느정도 크기를 예측하고 제한할 수 있어야 힙 메모리가 부족한 현상이 오지 않는다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/d4f62605-7c92-4219-af0c-4bd5d1d1c37e)

## PC와 SP

Registers는 CPU에 내장된 작은 저장 장치이다. 데이터를 임시로 저장하고 컴퓨터 성능을 높이는 데 도움이 된다. 레지스터의 크기는 컴퓨터 아키텍처에 따라 다를 수 있고, 다양한 유형의 레지스터가 각자의 역할을 수행한다. stack pointer와 program counter는 레지스터이다.

### Program Counter (PC)

program counter는 메모리에서 실행할 다음 명령어의 주소를 저장하는 레지스터이다. 예를 들어, 우리가 작성한 프로그램 코드가 있을 때, PC가 한줄 씩 코드를 읽어나가면서 다음 줄의 코드 주소를 PC에 저장한다.

컴퓨터 프로그램은 CPU에게 작업을 수행하도록 명령한다. 즉, 컴퓨터 프로그램은 이 명령(instructions)으로 이루어져 있고, CPU는 이러한 명령을 차례대로 가져와서 실행한다. 이때 program counter는 다음에 실행할 명령어의 주소를 저장하는 역할을 하는 레지스터인 것이다. Instruction pointer, Instruction address register 혹은 instruction counter라고 부르기도 한다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/7aaaa529-4a57-4634-84b9-45de90b8e697)

CPU가 명령어를 가져올 때마다 program counter는 1씩 증가한다. 컴퓨터를 재설정하면 해당 값은 다시 0이 된다.

### Stack Pointer (SP)

stack pointer는 스택의 마지막 프로그램 요청 주소를 저장하는 레지스터이다. 스택의 최상단 주소를 갖고 있다고 보면 된다.

예를 들어, 재귀 함수를 보면 함수 안에서 함수를 계속해서 호출한다. 그러다 종료 조건을 만나서 return하게 되면 함수는 스택 최상단으로 바로 복귀하는 게 아니라 직전 해당함수를 호출한 곳으로 복귀한다. 그렇게 순차적으로 복귀하다가 가장 최근에 호출한 함수의 위치, 즉 스택의 최상단을 가리키고 있는 게 stack pointer이다. 그러다 보니, 최상단 stack pointer만 알고 있다면 함수가 어디까지 호출되었는지 추적할 수 있다.

이렇듯 스택 포인터 혹은 스택 레지스터는 스택을 처리하는 데 도움이 되는 작은 레지스터이다. 마지막 프로그램 요청 주소를 저장한다. 여기에서 최근 입력된 요청은 스택의 최상단에 위치해 있게 된다. 스택에 프로그램 요청을 삽입하면 스택 포인터는 먼저 1씩 증가한다. 그런 다음 요청이 스택으로 push된다. 스택에서 프로그램 요청을 제거하면 요청이 먼저 스택에서 나오고 난 뒤에 스택 포인터가 1씩 감소한다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/4b807be7-8f54-4c25-a63a-bd3ae92e31f9)

### PC와 SP의 차이점?

스택 포인터는 호출 스택을 추적하는 게 목적인 CPU 레지스터이다. 반면 프로그램 카운터는 컴퓨터가 프로그램 순서 중 어디에 위치해 있는지를 나타내는 CPU 레지스터이다.

스택 포인터는 스택의 마지막 프로그램 요청 주소를 보유하는 반면, 프로그램 카운터는 실행되어야 할 다음 명령어의 주소를 보유한다.

그렇기 때문에 TEXT영역에 함수를 새로 등록할 때 사용하는 포인터는 따로 사용하고, 운영체제 상에서 PC 포인터의 값이 바뀌는 경우는 분기문을 통한 JUMP나 Call,  Context Switch를 통해 문맥 교환이 일어날 때, 즉 '**어셈블리 언어 동작’** 파트에서 PC값의 변화를 준다.

## PC와 SP를 적용해보기

함수를 호출하면 해당 함수를 호출한 위치를 stack pointer에 기록해둔 뒤, 이를 기반으로 함수 내부 코드를 처리한 뒤 다시 해당 함수가 return되는 순간부터 스택포인터를 줄여가면서 return address(해당 함수가 호출된 위치)를 만나면 그 return address를 program counter(PC)에 넣고 해당 PC를 실행하게끔 구조를 짜놓으면 프로세스 메모리 구조를 만들 수 있다고 생각했다.

## 빅 엔디안 vs 리틀 엔디안

<p align=center>
  <img src='https://www.tcpschool.com/lectures/img_c_byteorder_big_endian.png'>
  <img src='https://www.tcpschool.com/lectures/img_c_byteorder_little_endian.png'>
</p>

빅 엔디안 방식은 낮은 주소에 데이터의 높은 바이트(MSB, Most Significant Bit)부터 저장하는 방식입니다. 이 방식은 평소 우리가 숫자를 사용하는 선형 방식과 같은 방식입니다.

따라서 메모리에 저장된 순서 그대로 읽을 수 있으며, 이해하기가 쉽다는 장점을 가지고 있습니다.\

리틀 엔디안 방식은 낮은 주소에 데이터의 낮은 바이트(LSB, Least Significant Bit)부터 저장하는 방식입니다.

이 방식은 평소 우리가 숫자를 사용하는 선형 방식과는 반대로 거꾸로 읽어야 합니다.

대부분의 인텔 CPU 계열에서는 이 방식으로 데이터를 저장합니다.

```jsx
0x12345678

0x12, 0x34, 0x56, 0x78
```

이 정수는 각각 다음과 같이 1바이트값 4개로 구성됩니다.

빅 엔디안과 리틀 엔디안은 단지 저장해야 할 큰 데이터를 어떻게 나누어 저장하는가에 따른 차이일 뿐, 어느 방식이 더 우수하다고는 단정할 수 없습니다.

물리적으로 데이터를 조작하거나 산술 연산을 수행할 때에는 리틀 엔디안 방식이 더 효율적입니다.

하지만 데이터의 각 바이트를 배열처럼 취급할 때에는 빅 엔디안 방식이 더 적합합니다.

현재 여러분이 사용하는 대부분의 시스템은 인텔 기반의 윈도우이므로 리틀 엔디안 방식을 사용하고 있을 것입니다.

하지만 네트워크를 통해 데이터를 전송할 때에는 빅 엔디안 방식이 사용됩니다.

따라서 인텔 기반의 시스템에서 소켓 통신을 할 때는 바이트 순서에 신경을 써서 데이터를 전달해야 합니다.
