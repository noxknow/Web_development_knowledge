## 목차

- [1. 신기했던 Git의 방식](#신기했던-git의-방식) <br/>
- [2. 깃의 내부 구조](#깃의-내부-구조) <br/>
- [3. .git 파일이 생기는 과정](#git-파일이-생기는-과정) <br/>
  - [3.1 Objects 디렉터리](#objects-디렉터리) <br/>
  - [3.2 index 파일](#index-파일) <br/>
- [4. git의 hash 함수](#git의-hash-함수) <br/>
- [5. 블로킹과 논블로킹, 동기와 비동기 비교](#블로킹과-논블로킹-동기와-비동기-비교) <br/>
  - [5.1 Sync-Blocking](#1-sync-blocking) <br/>
  - [5.2 Sync-Nonblocking](#2-sync-nonblocking) <br/>
  - [5.3 Async-Nonblocking](#3-async-nonblocking) <br/>
  - [5.4 Async-blocking](#4-async-blocking) <br/>
- [6. 스냅샷 방식](#스냅샷-방식) <br/>
  - [6.1 백업 vs 스냅샷의 기본적인 차이](#백업-vs-스냅샷의-기본적인-차이) <br/>

## 신기했던 Git의 방식

Git은 update사항이 있다면 예를들어 100Mb 파일에 1Mb의 내용을 추가했을 때 100Mb와 1Mb로 두개의 파일이 생기는 것이 아니라 100Mb와 101Mb의 파일을 만든다는 사실이다. 이 편이 더 효율적이라고 한다. 누가봐도 전자가 효율적이지만 왜 후자가 더 효율적일까?

→ 나는 이유를 순회에 있다고 생각했다. 전자와 같이 저장을 하게된다면 업데이트 내역과 본문이 따로 해시값을 갖고 저장이 되는 것인데 그렇게 된다면 업데이트의 수가 많을 때 업데이트 내용과 본문을 찾기 위해 수많은 노드를 순회해야 할 것이다. 하지만 후자의 경우 가장 마지막 노드가 내용과 업데이트 내용을 둘 다 갖고 있는 최종파일이기 때문에 후자가 더 효율적이지 않을까라는 생각을 했다.

## 깃의 내부 구조

<aside>
⚡ 처음에는 깃의 작동 방식을 알아봤다. 평소에 git을 이용했지만 내부 구조까지는 파악하지 않았고, add와 commit을 할 때 어떤 식으로 영역이 할당되는지만 숙지하고 있었다. 블로그를 통해 git의 명령어만 사용했을 뿐 git의 내부 동작이 어떻게 돌아가는지 알지 못했는데 이번 기회를 통해 확인하고, 만들어 볼 수 있을 것 같다.

가장 먼저 알아야 할 부분은 내가 만들 .mit파일의 내부 구조이기 때문에 .git의 파일 내부에는 어떤 내용이 들어있는지 살펴봤다. 미션에서 init을 했을 때 .mit의 하위 디렉터리로 `objects`와 `index`를 만들라고 했는데 ‘그게 도대체 뭐지?’ 라고 생각했다가 .git의 내부 파일을 보고 아 이런 내용을 넣으면 되겠구나 라는걸 깨달았다. 

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/0a8ef55d-2a1a-4c3a-97d4-15e05411ad7e)

또한 `refs` 폴더 안에 `remotes`라는 폴더가 있는데 이곳에 연결해왔던 원격 저장소의 remote 내역이 들어있어서 놀랐다. cmd를 통해 써오던 명령어들이 이런 파일의 형태로 내 폴더 어딘가에 저장되고 있겠다는 생각을 확인해 보지 못했는데 이번 기회를 통해 눈으로 직접 확인할 수 있었다.

</aside>

## .git 파일이 생기는 과정

<aside>
⚡ `init` 명령어를 사용하거나 특정 저장소를 `clone` 명령어를 활용해 로컬 저장소로 복제하면 내부에 `.git` 이라는 디렉터리가 생성된다. 아무런 커밋도 이루어지지 않은 초기의 `.git` 디렉터리는 아래와 같다.

```
├── HEAD         # 현재 체크아웃(Checkout)한 브랜치(Branch)를 가리키는 파일
├── config       # 이 프로젝트에만 적용되는 설정 옵션
├── description  # GitWeb 프로그램에서 사용하는 파일
├── hooks        # 클라이언트 훅 또는 서버 훅 스크립트 파일이 존재하는 디렉터리
├── info         # .gitignore 파일처럼 무시할 파일의 패턴을 적어두는 디렉터리
├── objects      # 모든 파일의 내용을 저장하는 일종의 데이터베이스 역할의 디렉터리
└── refs         # 커밋 개체의 포인터를 저장하는 디렉터리
```

이중에서도 중요한 건 `HEAD` 파일과 `objects` , 그리고 `refs` 디렉터리이다. 여기서 objects 폴더와 index폴더가 생성되는 과정이 나온다. 

### Objects 디렉터리

파일을 `add`하게 되면 `objects` 디렉터리에 새로운 디렉터리가 생기고 index 파일이 생긴다. add한 파일은 objects 내부에서 일종의 데이터베이스처럼 저장되고 깃은 40자 길이의 체크섬 해시를 생성해서 파일의 이름을 지정하는데 해시의 첫 두글자를 디렉터리의 이름으로 쓰고 나머지 38글자를 파일 이름으로 사용한다. 

```
├── HEAD
├── index
├── objects
│   └── e3
│       └── 9e3dfc2b608453846cbf0e74aa69a1c0b7f311
└── refs
```

이후 `cat-file` 명령어에 `-p` 옵션을 준 뒤 내용을 보기 원하는 파일의 40자 길이의 해시값을 전달하면 파일 내용이 출력된다. `cat-file` 은 저장소 개체의 파일 내용이나 타입, 그리고 크기 등을 제공하는 명령어고 `-p` 옵션은 `pretty-print` 의 준말로 해시값을 전달하면 파일의 내용을 출력해주는 것을 의미한다.

추가적인 설명을 하자면, 깃은 파일을 저장할 때 Tree 또는 Blob 개체로 저장하며 이때 Tree는 쉽게 디렉터리를 의미하고 Blob는 일반 파일을 의미한다고 생각하면 된다. 만약 `-p` 옵션을 주지 않고 파일의 내용을 출력하고 싶다면 타입과 함께 해시값을 전달하면 된다! Tree 또는 Blob 외에도 Commit과 Tag 개체가 존재한다.

<aside>
✋ `cat-file` 과 같이 깃 자체의 내부 작동과 관련된 명령어를 Plumbing 명령어라 부르며, 기타 사용자의 편의성을 위해 존재하는 `add` , `commit` 같은 명령어를 Porcelain 명령어라 부른다.

</aside>

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/ca55a542-a35b-4e3e-bbfe-7d8b76161bc2)

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/cee9094d-c866-48db-92c0-7a36aef5a25f)

> 궁금해서 실제로 사용해봤다. 0a라는 디렉터리안에 3개의 파일이 들어있길래 각자 파일이 뭘 의미하는건지 궁금했다. 첫번째 파일은 commit 개체로 커밋의 대상이 되는 Tree 개체와 함께 커밋과 관련된 메타 데이터인 사용자 정보와 타임스탬프, 그리고 커밋 메시지가 저장되어있다. (+ 부모 노드 {이전 파일}) 여러 파일을 한 번에 스테이징 영역에 올리고 커밋할 경우 해당 파일이 모두 이 Tree 개체의 노드로 연결된다. tree를 자세히 보면 d7df1f~ 라고 나와있다.  d7파일을 찾아가 보니 똑같은 해쉬값을 가진 파일이 있었고 이를 통해 이 0a6f0d~ 라는 해쉬값의 파일이 d7df1f~의 값을 가지고 있다고 이해했다.
> 

> 두번째 파일은 tree 개체이며, 개체의 종류, 해시값, 내 파일의 이름인 `README.md`가 보인다.
> 

> 세번째 파일은 blob 개체로 파일안의 내용이 나온다. 눈으로 보면서 공부해서 더 이해가 잘 된 것 같다.
> 

여기서 디렉터리안에 파일이 1개 있는 경우도 2개, 3개 있는 경우도 있었다. 이 부분에서 안의 내용들은 다 공통점이 보일때도 안보일때도 있어서 같은 버전의 다른 정보값을 가지고 있는 것이 아니라 해쉬값의 앞부분이 같으면 같은 디렉터리에 저장된다고 이해했다.

### index 파일

`index` 파일은 스테이징 영역(Staging Area)의 정보를 저장하는 파일이다. 깃은 기본적으로 파일을 Committed, Modified, Staged라는 세 가지 상태로 관리한다. 이 중에서 Staged 상태는 커밋하기 직전의 상태를 의미하며, 다시 말해 스테이징 영역에 있는 파일들은 모두 커밋하기 직전의 파일들이고 Staged 상태이다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/35774b5b-3782-4786-aa67-729b5fd21385)

cf) [https://medium.com/daangn/앗-모르고-깃헙-github-에-올렸어요-50d48b343f0f](https://medium.com/daangn/%EC%95%97-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EA%B9%83%ED%97%99-github-%EC%97%90-%EC%98%AC%EB%A0%B8%EC%96%B4%EC%9A%94-50d48b343f0f)

</aside>

## git의 hash 함수

❓git은 기존에는 SHA-1을 사용했다고 한다. 하지만 현재는 SHA-256을 쓰는데 이유가 뭘까? 아래의 이유와 더불어 심지어는 계산도 빠르다고 한다! 

1. SHA-1의 보안상의 문제 
2. SHA-256의 256비트 해시(일반적인 보안 관행과 일치할 만큼 충분히 길며 성능 및 디스크 사용량을 저하시킬 만큼 지나치게 길지 않음).
3. 고품질의 구현이 가능한 SHA-256

## 블로킹과 논블로킹, 동기와 비동기 비교

> 미션을 수행하던 중 파일을 읽어오는 I/O 작업에서 동기/비동기 문제를 만나게 되었다. 이때 문제는 파일을 읽어오는 것이기 때문에 작업을 비동기로 해야 한다는 점이었는데 이 과정에서 블로킹과 논 블로킹에 대해 더 자세히 알고 싶어졌다.
> 

### 1) Sync-Blocking

동기를 블로킹처럼 실행하는 것은 이해하기 쉽다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/2d918f47-9e75-4cb0-acc1-fd3fbbf704dd)

함수 A는 함수 B의 리턴값을 필요로 한다(**동기**). 그래서 제어권을 함수 B에게 넘겨주고, 함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄때까지 기다린다(**블로킹**).

### 2) Sync-Nonblocking

그런데, 동기를 논블로킹처럼 작동시킬 수 있다. 

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/e9bdbb28-5ec4-437b-8150-a9e8d3d0c228)

A 함수는 B 함수를 호출한다. 이 때 **A 함수는 B 함수에게 제어권을 주지 않고**, 자신의 코드를 계속 실행한다(**논블로킹**).

그런데 **A 함수는 B 함수의 리턴값이 필요하기 때문**에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다(**동기**).

즉, 논블로킹인 동시에 동기인 것이다.

### 3) Async-Nonblocking

비동기 논블로킹은 이해하기 쉽다. A 함수는 B 함수를 호출한다.

이 때 제어권을 B 함수에 주지 않고, 자신이 계속 가지고 있는다(**논블로킹**). 따라서 B 함수를 호출한 이후에도 멈추지 않고 자신의 코드를 계속 실행한다.

그리고 B 함수를 호출할 때 **콜백함수**를 함께 준다. B 함수는 자신의 작업이 끝나면 A 함수가 준 콜백 함수를 실행한다(**비동기**).

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/9f3fa682-1367-42f6-974c-978cddf23077)

### 4) Async-blocking

Async-blocking의 경우는 사실 잘 마주하기 쉽지 않다.

A 함수는 B 함수의 리턴값에 신경쓰지 않고, 콜백함수를 보낸다(**비동기**).

그런데, B 함수의 작업에 관심없음에도 불구하고, A 함수는 B 함수에게 제어권을 넘긴다(**블로킹**).

따라서, A 함수는 자신과 관련 없는 B 함수의 작업이 끝날 때까지 기다려야 한다.

![image](https://github.com/noxknow/Web_development_knowledge/assets/122594223/9c3ef452-4169-4d0b-a423-e540d44f3893)

Async-blocking의 경우 sync-blocking과 성능의 차이가 비슷하기 때문에 사용하는 경우는 거의 없다.

cf) [https://velog.io/@nittre/블로킹-Vs.-논블로킹-동기-Vs.-비동기](https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0)

## 스냅샷 방식

### **스냅샷(Snapshot) 이란?**

사진을 찍듯이 특정 시간(시점)에 데이터 저장 장치(스토리지)의 파일 시스템을 포착해  별도의 파일이나 이미지로 저장, 보관하는 기술을 말한다. 그래서 스냅샷 기능을 이용하여 데이터를 저장하면 유실된 데이터 복원과 일정 시점의 상태로 데이터를 복원할 수 있습니다.

예를 들면, Windows OS의 복원 지점과 같이 장애나 데이터 손상 시 스냅샷을 생성한 시점으로 데이터 복구가 가능하게 된다.

### **스냅샷 방식**

스냅샷 방식은 크게 Cow(Copy on Write)와 RoW(Redirect on Write)로 나눌 수 있다.

**Cow 방식**의 경우 원본 데이터에 대한 메타데이터만 활용해 스냅샷을 생성하고, 나중에 원본 데이터에 수정이 필요한 시점에 해당 데이터를 스냅샷이 저장된 스토리지 공간으로 복사한다. 이후 데이터를 수정하기 때문에 스냅샷 데이터는 일관성을 유지할 수 있고, 변경된 데이터만을 저장해 스토리지 공간을 효율적으로 사용할 수 있게된다.

**RoW 방식**은 CoW 방식에서의 I/O 과정에서 발생하는 오버헤드를 줄여줍니다. RoW 방식의 경우 스냅샷을 위한 별도의 스토리지 공간을 확보할 필요가 없으며, 데이터 변경이 필요한 경우 기존 데이터와 스냅샷 리스트를 고정(Freeze)한 채 새로운 공간에 수정된 데이터를 작성해 관리한다.

이러한 RoW 방식은 두 번의 쓰기 작업이 필요한 CoW 방식(스냅샷 공간에 원본 데이터를 한 차례 삽입(Write)하고 뒤이어 수정 사항을 입력(Write))과 달리 새로운 공간에 단 한 차례만 수정 데이터를 입력(Write)하면 되기 때문에 보다 나은 성능을 보여준다.

### **백업 vs 스냅샷의 기본적인 차이**

- 백업 : 원본 데이터를 그대로 복사해 다른 곳에 저장하기때문에 스토리지 상에 동일한 공간이 필요하다.
- 스냅샷 : 초기 생성 시 혹은 데이터 변경이 있기 전까지는 스토리지의 공간을 차지하지 않으며, 메타데이터의 복사본에 해당하여 생성시 시간이 오래 걸리지 않고, 장애가 발행해도 빠르게 데이터를 복원할 수 있다.

cf) https://leinoi.tistory.com/8

cf) https://kim-oriental.tistory.com/29 → CLI 인터페이스 구현
